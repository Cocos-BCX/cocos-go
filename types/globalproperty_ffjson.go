// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: globalproperty.go

package types

import (
	"bytes"
	"encoding/json"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *ChainParametersType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChainParametersType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.CurrentFees != nil {
		/* Struct fall back. type=types.FeeSchedule kind=struct */
		buf.WriteString(`{"current_fees":`)
		err = buf.Encode(j.CurrentFees)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`{"current_fees":null`)
	}
	buf.WriteString(`,"block_interval":`)
	fflib.FormatBits2(buf, uint64(j.BlockInterval), 10, false)
	buf.WriteString(`,"maintenance_interval":`)
	fflib.FormatBits2(buf, uint64(j.MaintenanceInterval), 10, false)
	buf.WriteString(`,"maintenance_skip_slots":`)
	fflib.FormatBits2(buf, uint64(j.MaintenanceSkipSlots), 10, false)
	buf.WriteString(`,"committee_proposal_review_period ":`)
	fflib.FormatBits2(buf, uint64(j.CommitteeProposalReviewPeriod), 10, false)
	buf.WriteString(`,"maximum_block_size":`)
	fflib.FormatBits2(buf, uint64(j.MaximumBlockSize), 10, false)
	buf.WriteString(`,"maximum_time_until_expiration":`)
	fflib.FormatBits2(buf, uint64(j.MaximumTimeUntilExpiration), 10, false)
	buf.WriteString(`,"maximum_proposal_lifetime":`)
	fflib.FormatBits2(buf, uint64(j.MaximumProposalLifetime), 10, false)
	buf.WriteString(`,"maximum_asset_feed_publishers":`)
	fflib.FormatBits2(buf, uint64(j.MaximumAssetFeedPublishers), 10, false)
	buf.WriteString(`,"witness_number_of_election":`)
	fflib.FormatBits2(buf, uint64(j.WitnessNumberOfElection), 10, false)
	buf.WriteString(`,"committee_number_of_election":`)
	fflib.FormatBits2(buf, uint64(j.CommitteeNumberOfElection), 10, false)
	buf.WriteString(`,"maximum_authority_membership":`)
	fflib.FormatBits2(buf, uint64(j.MaximumAuthorityMembership), 10, false)
	buf.WriteString(`,"cashback_gas_period_seconds":`)
	fflib.FormatBits2(buf, uint64(j.CashbackGasPeriodSeconds), 10, false)
	buf.WriteString(`,"cashback_vb_period_seconds":`)
	fflib.FormatBits2(buf, uint64(j.CashbackVbPeriodSeconds), 10, false)
	buf.WriteString(`,"cashback_vote_period_seconds":`)
	fflib.FormatBits2(buf, uint64(j.CashbackVotePeriodSeconds), 10, false)
	buf.WriteString(`,"witness_pay_per_block":`)
	fflib.FormatBits2(buf, uint64(j.WitnessPayPerBlock), 10, j.WitnessPayPerBlock < 0)
	buf.WriteString(`,"witness_pay_vesting_seconds":`)
	fflib.FormatBits2(buf, uint64(j.WitnessPayVestingSeconds), 10, false)
	buf.WriteString(`,"worker_budget_per_day":`)
	fflib.FormatBits2(buf, uint64(j.WorkerBudgetPerDay), 10, j.WorkerBudgetPerDay < 0)
	buf.WriteString(`,"accounts_per_fee_scale":`)
	fflib.FormatBits2(buf, uint64(j.AccountsPerFeeScale), 10, false)
	buf.WriteString(`,"account_fee_scale_bitshifts":`)
	fflib.FormatBits2(buf, uint64(j.AccountFeeScaleBitshifts), 10, false)
	buf.WriteString(`,"max_authority_depth":`)
	fflib.FormatBits2(buf, uint64(j.MaxAuthorityDepth), 10, false)
	buf.WriteString(`,"maximum_run_time_ratio":`)
	fflib.FormatBits2(buf, uint64(j.MaximumRunTimeRatio), 10, false)
	buf.WriteString(`,"maximum_nh_asset_order_expiration":`)
	fflib.FormatBits2(buf, uint64(j.MaximumNhAssetOrderExpiration), 10, false)
	buf.WriteString(`,"assigned_task_life_cycle":`)
	fflib.FormatBits2(buf, uint64(j.AssignedTaskLifeCycle), 10, false)
	buf.WriteString(`,"crontab_suspend_threshold":`)
	fflib.FormatBits2(buf, uint64(j.CrontabSuspendThreshold), 10, false)
	buf.WriteString(`,"crontab_suspend_expiration":`)
	fflib.FormatBits2(buf, uint64(j.CrontabSuspendExpiration), 10, false)
	buf.WriteString(`,"witness_candidate_freeze":`)
	fflib.FormatBits2(buf, uint64(j.WitnessCandidateFreeze), 10, j.WitnessCandidateFreeze < 0)
	buf.WriteString(`,"committee_candidate_freeze":`)
	fflib.FormatBits2(buf, uint64(j.CommitteeCandidateFreeze), 10, j.CommitteeCandidateFreeze < 0)
	buf.WriteString(`,"candidate_award_budget":`)
	fflib.FormatBits2(buf, uint64(j.CandidateAwardBudget), 10, j.CandidateAwardBudget < 0)
	buf.WriteString(`,"committee_percent_of_candidate_award":`)
	fflib.FormatBits2(buf, uint64(j.CommitteePercentOfCandidateAward), 10, false)
	buf.WriteString(`,"unsuccessful_candidates_percent":`)
	fflib.FormatBits2(buf, uint64(j.UnsuccessfulCandidatesPercent), 10, false)
	buf.WriteString(`,"extensions":`)

	{

		obj, err = j.Extensions.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChainParametersTypebase = iota
	ffjtChainParametersTypenosuchkey

	ffjtChainParametersTypeCurrentFees

	ffjtChainParametersTypeBlockInterval

	ffjtChainParametersTypeMaintenanceInterval

	ffjtChainParametersTypeMaintenanceSkipSlots

	ffjtChainParametersTypeCommitteeProposalReviewPeriod

	ffjtChainParametersTypeMaximumBlockSize

	ffjtChainParametersTypeMaximumTimeUntilExpiration

	ffjtChainParametersTypeMaximumProposalLifetime

	ffjtChainParametersTypeMaximumAssetFeedPublishers

	ffjtChainParametersTypeWitnessNumberOfElection

	ffjtChainParametersTypeCommitteeNumberOfElection

	ffjtChainParametersTypeMaximumAuthorityMembership

	ffjtChainParametersTypeCashbackGasPeriodSeconds

	ffjtChainParametersTypeCashbackVbPeriodSeconds

	ffjtChainParametersTypeCashbackVotePeriodSeconds

	ffjtChainParametersTypeWitnessPayPerBlock

	ffjtChainParametersTypeWitnessPayVestingSeconds

	ffjtChainParametersTypeWorkerBudgetPerDay

	ffjtChainParametersTypeAccountsPerFeeScale

	ffjtChainParametersTypeAccountFeeScaleBitshifts

	ffjtChainParametersTypeMaxAuthorityDepth

	ffjtChainParametersTypeMaximumRunTimeRatio

	ffjtChainParametersTypeMaximumNhAssetOrderExpiration

	ffjtChainParametersTypeAssignedTaskLifeCycle

	ffjtChainParametersTypeCrontabSuspendThreshold

	ffjtChainParametersTypeCrontabSuspendExpiration

	ffjtChainParametersTypeWitnessCandidateFreeze

	ffjtChainParametersTypeCommitteeCandidateFreeze

	ffjtChainParametersTypeCandidateAwardBudget

	ffjtChainParametersTypeCommitteePercentOfCandidateAward

	ffjtChainParametersTypeUnsuccessfulCandidatesPercent

	ffjtChainParametersTypeExtensions
)

var ffjKeyChainParametersTypeCurrentFees = []byte("current_fees")

var ffjKeyChainParametersTypeBlockInterval = []byte("block_interval")

var ffjKeyChainParametersTypeMaintenanceInterval = []byte("maintenance_interval")

var ffjKeyChainParametersTypeMaintenanceSkipSlots = []byte("maintenance_skip_slots")

var ffjKeyChainParametersTypeCommitteeProposalReviewPeriod = []byte("committee_proposal_review_period ")

var ffjKeyChainParametersTypeMaximumBlockSize = []byte("maximum_block_size")

var ffjKeyChainParametersTypeMaximumTimeUntilExpiration = []byte("maximum_time_until_expiration")

var ffjKeyChainParametersTypeMaximumProposalLifetime = []byte("maximum_proposal_lifetime")

var ffjKeyChainParametersTypeMaximumAssetFeedPublishers = []byte("maximum_asset_feed_publishers")

var ffjKeyChainParametersTypeWitnessNumberOfElection = []byte("witness_number_of_election")

var ffjKeyChainParametersTypeCommitteeNumberOfElection = []byte("committee_number_of_election")

var ffjKeyChainParametersTypeMaximumAuthorityMembership = []byte("maximum_authority_membership")

var ffjKeyChainParametersTypeCashbackGasPeriodSeconds = []byte("cashback_gas_period_seconds")

var ffjKeyChainParametersTypeCashbackVbPeriodSeconds = []byte("cashback_vb_period_seconds")

var ffjKeyChainParametersTypeCashbackVotePeriodSeconds = []byte("cashback_vote_period_seconds")

var ffjKeyChainParametersTypeWitnessPayPerBlock = []byte("witness_pay_per_block")

var ffjKeyChainParametersTypeWitnessPayVestingSeconds = []byte("witness_pay_vesting_seconds")

var ffjKeyChainParametersTypeWorkerBudgetPerDay = []byte("worker_budget_per_day")

var ffjKeyChainParametersTypeAccountsPerFeeScale = []byte("accounts_per_fee_scale")

var ffjKeyChainParametersTypeAccountFeeScaleBitshifts = []byte("account_fee_scale_bitshifts")

var ffjKeyChainParametersTypeMaxAuthorityDepth = []byte("max_authority_depth")

var ffjKeyChainParametersTypeMaximumRunTimeRatio = []byte("maximum_run_time_ratio")

var ffjKeyChainParametersTypeMaximumNhAssetOrderExpiration = []byte("maximum_nh_asset_order_expiration")

var ffjKeyChainParametersTypeAssignedTaskLifeCycle = []byte("assigned_task_life_cycle")

var ffjKeyChainParametersTypeCrontabSuspendThreshold = []byte("crontab_suspend_threshold")

var ffjKeyChainParametersTypeCrontabSuspendExpiration = []byte("crontab_suspend_expiration")

var ffjKeyChainParametersTypeWitnessCandidateFreeze = []byte("witness_candidate_freeze")

var ffjKeyChainParametersTypeCommitteeCandidateFreeze = []byte("committee_candidate_freeze")

var ffjKeyChainParametersTypeCandidateAwardBudget = []byte("candidate_award_budget")

var ffjKeyChainParametersTypeCommitteePercentOfCandidateAward = []byte("committee_percent_of_candidate_award")

var ffjKeyChainParametersTypeUnsuccessfulCandidatesPercent = []byte("unsuccessful_candidates_percent")

var ffjKeyChainParametersTypeExtensions = []byte("extensions")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChainParametersType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChainParametersType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChainParametersTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChainParametersTypenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyChainParametersTypeAccountsPerFeeScale, kn) {
						currentKey = ffjtChainParametersTypeAccountsPerFeeScale
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeAccountFeeScaleBitshifts, kn) {
						currentKey = ffjtChainParametersTypeAccountFeeScaleBitshifts
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeAssignedTaskLifeCycle, kn) {
						currentKey = ffjtChainParametersTypeAssignedTaskLifeCycle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffjKeyChainParametersTypeBlockInterval, kn) {
						currentKey = ffjtChainParametersTypeBlockInterval
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyChainParametersTypeCurrentFees, kn) {
						currentKey = ffjtChainParametersTypeCurrentFees
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCommitteeProposalReviewPeriod, kn) {
						currentKey = ffjtChainParametersTypeCommitteeProposalReviewPeriod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCommitteeNumberOfElection, kn) {
						currentKey = ffjtChainParametersTypeCommitteeNumberOfElection
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCashbackGasPeriodSeconds, kn) {
						currentKey = ffjtChainParametersTypeCashbackGasPeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCashbackVbPeriodSeconds, kn) {
						currentKey = ffjtChainParametersTypeCashbackVbPeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCashbackVotePeriodSeconds, kn) {
						currentKey = ffjtChainParametersTypeCashbackVotePeriodSeconds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCrontabSuspendThreshold, kn) {
						currentKey = ffjtChainParametersTypeCrontabSuspendThreshold
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCrontabSuspendExpiration, kn) {
						currentKey = ffjtChainParametersTypeCrontabSuspendExpiration
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCommitteeCandidateFreeze, kn) {
						currentKey = ffjtChainParametersTypeCommitteeCandidateFreeze
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCandidateAwardBudget, kn) {
						currentKey = ffjtChainParametersTypeCandidateAwardBudget
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeCommitteePercentOfCandidateAward, kn) {
						currentKey = ffjtChainParametersTypeCommitteePercentOfCandidateAward
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyChainParametersTypeExtensions, kn) {
						currentKey = ffjtChainParametersTypeExtensions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyChainParametersTypeMaintenanceInterval, kn) {
						currentKey = ffjtChainParametersTypeMaintenanceInterval
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaintenanceSkipSlots, kn) {
						currentKey = ffjtChainParametersTypeMaintenanceSkipSlots
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaximumBlockSize, kn) {
						currentKey = ffjtChainParametersTypeMaximumBlockSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaximumTimeUntilExpiration, kn) {
						currentKey = ffjtChainParametersTypeMaximumTimeUntilExpiration
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaximumProposalLifetime, kn) {
						currentKey = ffjtChainParametersTypeMaximumProposalLifetime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaximumAssetFeedPublishers, kn) {
						currentKey = ffjtChainParametersTypeMaximumAssetFeedPublishers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaximumAuthorityMembership, kn) {
						currentKey = ffjtChainParametersTypeMaximumAuthorityMembership
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaxAuthorityDepth, kn) {
						currentKey = ffjtChainParametersTypeMaxAuthorityDepth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaximumRunTimeRatio, kn) {
						currentKey = ffjtChainParametersTypeMaximumRunTimeRatio
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeMaximumNhAssetOrderExpiration, kn) {
						currentKey = ffjtChainParametersTypeMaximumNhAssetOrderExpiration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChainParametersTypeUnsuccessfulCandidatesPercent, kn) {
						currentKey = ffjtChainParametersTypeUnsuccessfulCandidatesPercent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyChainParametersTypeWitnessNumberOfElection, kn) {
						currentKey = ffjtChainParametersTypeWitnessNumberOfElection
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeWitnessPayPerBlock, kn) {
						currentKey = ffjtChainParametersTypeWitnessPayPerBlock
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeWitnessPayVestingSeconds, kn) {
						currentKey = ffjtChainParametersTypeWitnessPayVestingSeconds
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeWorkerBudgetPerDay, kn) {
						currentKey = ffjtChainParametersTypeWorkerBudgetPerDay
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChainParametersTypeWitnessCandidateFreeze, kn) {
						currentKey = ffjtChainParametersTypeWitnessCandidateFreeze
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeExtensions, kn) {
					currentKey = ffjtChainParametersTypeExtensions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeUnsuccessfulCandidatesPercent, kn) {
					currentKey = ffjtChainParametersTypeUnsuccessfulCandidatesPercent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeCommitteePercentOfCandidateAward, kn) {
					currentKey = ffjtChainParametersTypeCommitteePercentOfCandidateAward
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeCandidateAwardBudget, kn) {
					currentKey = ffjtChainParametersTypeCandidateAwardBudget
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeCommitteeCandidateFreeze, kn) {
					currentKey = ffjtChainParametersTypeCommitteeCandidateFreeze
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeWitnessCandidateFreeze, kn) {
					currentKey = ffjtChainParametersTypeWitnessCandidateFreeze
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeCrontabSuspendExpiration, kn) {
					currentKey = ffjtChainParametersTypeCrontabSuspendExpiration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeCrontabSuspendThreshold, kn) {
					currentKey = ffjtChainParametersTypeCrontabSuspendThreshold
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeAssignedTaskLifeCycle, kn) {
					currentKey = ffjtChainParametersTypeAssignedTaskLifeCycle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeMaximumNhAssetOrderExpiration, kn) {
					currentKey = ffjtChainParametersTypeMaximumNhAssetOrderExpiration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeMaximumRunTimeRatio, kn) {
					currentKey = ffjtChainParametersTypeMaximumRunTimeRatio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeMaxAuthorityDepth, kn) {
					currentKey = ffjtChainParametersTypeMaxAuthorityDepth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeAccountFeeScaleBitshifts, kn) {
					currentKey = ffjtChainParametersTypeAccountFeeScaleBitshifts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeAccountsPerFeeScale, kn) {
					currentKey = ffjtChainParametersTypeAccountsPerFeeScale
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeWorkerBudgetPerDay, kn) {
					currentKey = ffjtChainParametersTypeWorkerBudgetPerDay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeWitnessPayVestingSeconds, kn) {
					currentKey = ffjtChainParametersTypeWitnessPayVestingSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeWitnessPayPerBlock, kn) {
					currentKey = ffjtChainParametersTypeWitnessPayPerBlock
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeCashbackVotePeriodSeconds, kn) {
					currentKey = ffjtChainParametersTypeCashbackVotePeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeCashbackVbPeriodSeconds, kn) {
					currentKey = ffjtChainParametersTypeCashbackVbPeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeCashbackGasPeriodSeconds, kn) {
					currentKey = ffjtChainParametersTypeCashbackGasPeriodSeconds
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeMaximumAuthorityMembership, kn) {
					currentKey = ffjtChainParametersTypeMaximumAuthorityMembership
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeCommitteeNumberOfElection, kn) {
					currentKey = ffjtChainParametersTypeCommitteeNumberOfElection
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeWitnessNumberOfElection, kn) {
					currentKey = ffjtChainParametersTypeWitnessNumberOfElection
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeMaximumAssetFeedPublishers, kn) {
					currentKey = ffjtChainParametersTypeMaximumAssetFeedPublishers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeMaximumProposalLifetime, kn) {
					currentKey = ffjtChainParametersTypeMaximumProposalLifetime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeMaximumTimeUntilExpiration, kn) {
					currentKey = ffjtChainParametersTypeMaximumTimeUntilExpiration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeMaximumBlockSize, kn) {
					currentKey = ffjtChainParametersTypeMaximumBlockSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeCommitteeProposalReviewPeriod, kn) {
					currentKey = ffjtChainParametersTypeCommitteeProposalReviewPeriod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeMaintenanceSkipSlots, kn) {
					currentKey = ffjtChainParametersTypeMaintenanceSkipSlots
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyChainParametersTypeMaintenanceInterval, kn) {
					currentKey = ffjtChainParametersTypeMaintenanceInterval
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeBlockInterval, kn) {
					currentKey = ffjtChainParametersTypeBlockInterval
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChainParametersTypeCurrentFees, kn) {
					currentKey = ffjtChainParametersTypeCurrentFees
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChainParametersTypenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChainParametersTypeCurrentFees:
					goto handle_CurrentFees

				case ffjtChainParametersTypeBlockInterval:
					goto handle_BlockInterval

				case ffjtChainParametersTypeMaintenanceInterval:
					goto handle_MaintenanceInterval

				case ffjtChainParametersTypeMaintenanceSkipSlots:
					goto handle_MaintenanceSkipSlots

				case ffjtChainParametersTypeCommitteeProposalReviewPeriod:
					goto handle_CommitteeProposalReviewPeriod

				case ffjtChainParametersTypeMaximumBlockSize:
					goto handle_MaximumBlockSize

				case ffjtChainParametersTypeMaximumTimeUntilExpiration:
					goto handle_MaximumTimeUntilExpiration

				case ffjtChainParametersTypeMaximumProposalLifetime:
					goto handle_MaximumProposalLifetime

				case ffjtChainParametersTypeMaximumAssetFeedPublishers:
					goto handle_MaximumAssetFeedPublishers

				case ffjtChainParametersTypeWitnessNumberOfElection:
					goto handle_WitnessNumberOfElection

				case ffjtChainParametersTypeCommitteeNumberOfElection:
					goto handle_CommitteeNumberOfElection

				case ffjtChainParametersTypeMaximumAuthorityMembership:
					goto handle_MaximumAuthorityMembership

				case ffjtChainParametersTypeCashbackGasPeriodSeconds:
					goto handle_CashbackGasPeriodSeconds

				case ffjtChainParametersTypeCashbackVbPeriodSeconds:
					goto handle_CashbackVbPeriodSeconds

				case ffjtChainParametersTypeCashbackVotePeriodSeconds:
					goto handle_CashbackVotePeriodSeconds

				case ffjtChainParametersTypeWitnessPayPerBlock:
					goto handle_WitnessPayPerBlock

				case ffjtChainParametersTypeWitnessPayVestingSeconds:
					goto handle_WitnessPayVestingSeconds

				case ffjtChainParametersTypeWorkerBudgetPerDay:
					goto handle_WorkerBudgetPerDay

				case ffjtChainParametersTypeAccountsPerFeeScale:
					goto handle_AccountsPerFeeScale

				case ffjtChainParametersTypeAccountFeeScaleBitshifts:
					goto handle_AccountFeeScaleBitshifts

				case ffjtChainParametersTypeMaxAuthorityDepth:
					goto handle_MaxAuthorityDepth

				case ffjtChainParametersTypeMaximumRunTimeRatio:
					goto handle_MaximumRunTimeRatio

				case ffjtChainParametersTypeMaximumNhAssetOrderExpiration:
					goto handle_MaximumNhAssetOrderExpiration

				case ffjtChainParametersTypeAssignedTaskLifeCycle:
					goto handle_AssignedTaskLifeCycle

				case ffjtChainParametersTypeCrontabSuspendThreshold:
					goto handle_CrontabSuspendThreshold

				case ffjtChainParametersTypeCrontabSuspendExpiration:
					goto handle_CrontabSuspendExpiration

				case ffjtChainParametersTypeWitnessCandidateFreeze:
					goto handle_WitnessCandidateFreeze

				case ffjtChainParametersTypeCommitteeCandidateFreeze:
					goto handle_CommitteeCandidateFreeze

				case ffjtChainParametersTypeCandidateAwardBudget:
					goto handle_CandidateAwardBudget

				case ffjtChainParametersTypeCommitteePercentOfCandidateAward:
					goto handle_CommitteePercentOfCandidateAward

				case ffjtChainParametersTypeUnsuccessfulCandidatesPercent:
					goto handle_UnsuccessfulCandidatesPercent

				case ffjtChainParametersTypeExtensions:
					goto handle_Extensions

				case ffjtChainParametersTypenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_CurrentFees:

	/* handler: j.CurrentFees type=types.FeeSchedule kind=struct quoted=false*/

	{
		/* Falling back. type=types.FeeSchedule kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.CurrentFees)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BlockInterval:

	/* handler: j.BlockInterval type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.BlockInterval.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaintenanceInterval:

	/* handler: j.MaintenanceInterval type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaintenanceInterval.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaintenanceSkipSlots:

	/* handler: j.MaintenanceSkipSlots type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaintenanceSkipSlots.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommitteeProposalReviewPeriod:

	/* handler: j.CommitteeProposalReviewPeriod type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommitteeProposalReviewPeriod.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumBlockSize:

	/* handler: j.MaximumBlockSize type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumBlockSize.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumTimeUntilExpiration:

	/* handler: j.MaximumTimeUntilExpiration type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumTimeUntilExpiration.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumProposalLifetime:

	/* handler: j.MaximumProposalLifetime type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumProposalLifetime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumAssetFeedPublishers:

	/* handler: j.MaximumAssetFeedPublishers type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumAssetFeedPublishers.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WitnessNumberOfElection:

	/* handler: j.WitnessNumberOfElection type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WitnessNumberOfElection.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommitteeNumberOfElection:

	/* handler: j.CommitteeNumberOfElection type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommitteeNumberOfElection.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumAuthorityMembership:

	/* handler: j.MaximumAuthorityMembership type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumAuthorityMembership.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashbackGasPeriodSeconds:

	/* handler: j.CashbackGasPeriodSeconds type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CashbackGasPeriodSeconds.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashbackVbPeriodSeconds:

	/* handler: j.CashbackVbPeriodSeconds type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CashbackVbPeriodSeconds.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CashbackVotePeriodSeconds:

	/* handler: j.CashbackVotePeriodSeconds type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CashbackVotePeriodSeconds.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WitnessPayPerBlock:

	/* handler: j.WitnessPayPerBlock type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WitnessPayPerBlock.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WitnessPayVestingSeconds:

	/* handler: j.WitnessPayVestingSeconds type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WitnessPayVestingSeconds.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WorkerBudgetPerDay:

	/* handler: j.WorkerBudgetPerDay type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WorkerBudgetPerDay.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccountsPerFeeScale:

	/* handler: j.AccountsPerFeeScale type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AccountsPerFeeScale.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AccountFeeScaleBitshifts:

	/* handler: j.AccountFeeScaleBitshifts type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AccountFeeScaleBitshifts.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxAuthorityDepth:

	/* handler: j.MaxAuthorityDepth type=types.UInt8 kind=uint8 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaxAuthorityDepth.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumRunTimeRatio:

	/* handler: j.MaximumRunTimeRatio type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumRunTimeRatio.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaximumNhAssetOrderExpiration:

	/* handler: j.MaximumNhAssetOrderExpiration type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.MaximumNhAssetOrderExpiration.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AssignedTaskLifeCycle:

	/* handler: j.AssignedTaskLifeCycle type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.AssignedTaskLifeCycle.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CrontabSuspendThreshold:

	/* handler: j.CrontabSuspendThreshold type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CrontabSuspendThreshold.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CrontabSuspendExpiration:

	/* handler: j.CrontabSuspendExpiration type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CrontabSuspendExpiration.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WitnessCandidateFreeze:

	/* handler: j.WitnessCandidateFreeze type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.WitnessCandidateFreeze.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommitteeCandidateFreeze:

	/* handler: j.CommitteeCandidateFreeze type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommitteeCandidateFreeze.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CandidateAwardBudget:

	/* handler: j.CandidateAwardBudget type=types.Int64 kind=int64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CandidateAwardBudget.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CommitteePercentOfCandidateAward:

	/* handler: j.CommitteePercentOfCandidateAward type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CommitteePercentOfCandidateAward.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UnsuccessfulCandidatesPercent:

	/* handler: j.UnsuccessfulCandidatesPercent type=types.UInt16 kind=uint16 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.UnsuccessfulCandidatesPercent.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Extensions:

	/* handler: j.Extensions type=types.Extensions kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Extensions.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GlobalProperty) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GlobalProperty) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)

	{

		obj, err = j.ID.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"parameters":`)

	{

		err = j.Parameters.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	if j.PendingParameters != nil {
		buf.WriteString(`,"pending_parameters":`)

		{

			err = j.PendingParameters.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"pending_parameters":null`)
	}
	buf.WriteString(`,"next_available_vote_id":`)
	fflib.FormatBits2(buf, uint64(j.NextAvailableVoteID), 10, false)
	buf.WriteString(`,"active_committee_members":`)
	if j.ActiveCommitteeMembers != nil {
		buf.WriteString(`[`)
		for i, v := range j.ActiveCommitteeMembers {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"active_witnesses":`)
	if j.ActiveWitnesses != nil {
		buf.WriteString(`[`)
		for i, v := range j.ActiveWitnesses {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				obj, err = v.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGlobalPropertybase = iota
	ffjtGlobalPropertynosuchkey

	ffjtGlobalPropertyID

	ffjtGlobalPropertyParameters

	ffjtGlobalPropertyPendingParameters

	ffjtGlobalPropertyNextAvailableVoteID

	ffjtGlobalPropertyActiveCommitteeMembers

	ffjtGlobalPropertyActiveWitnesses
)

var ffjKeyGlobalPropertyID = []byte("id")

var ffjKeyGlobalPropertyParameters = []byte("parameters")

var ffjKeyGlobalPropertyPendingParameters = []byte("pending_parameters")

var ffjKeyGlobalPropertyNextAvailableVoteID = []byte("next_available_vote_id")

var ffjKeyGlobalPropertyActiveCommitteeMembers = []byte("active_committee_members")

var ffjKeyGlobalPropertyActiveWitnesses = []byte("active_witnesses")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GlobalProperty) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GlobalProperty) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGlobalPropertybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGlobalPropertynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyGlobalPropertyActiveCommitteeMembers, kn) {
						currentKey = ffjtGlobalPropertyActiveCommitteeMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGlobalPropertyActiveWitnesses, kn) {
						currentKey = ffjtGlobalPropertyActiveWitnesses
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyGlobalPropertyID, kn) {
						currentKey = ffjtGlobalPropertyID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyGlobalPropertyNextAvailableVoteID, kn) {
						currentKey = ffjtGlobalPropertyNextAvailableVoteID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyGlobalPropertyParameters, kn) {
						currentKey = ffjtGlobalPropertyParameters
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGlobalPropertyPendingParameters, kn) {
						currentKey = ffjtGlobalPropertyPendingParameters
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyGlobalPropertyActiveWitnesses, kn) {
					currentKey = ffjtGlobalPropertyActiveWitnesses
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGlobalPropertyActiveCommitteeMembers, kn) {
					currentKey = ffjtGlobalPropertyActiveCommitteeMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGlobalPropertyNextAvailableVoteID, kn) {
					currentKey = ffjtGlobalPropertyNextAvailableVoteID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGlobalPropertyPendingParameters, kn) {
					currentKey = ffjtGlobalPropertyPendingParameters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyGlobalPropertyParameters, kn) {
					currentKey = ffjtGlobalPropertyParameters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGlobalPropertyID, kn) {
					currentKey = ffjtGlobalPropertyID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGlobalPropertynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGlobalPropertyID:
					goto handle_ID

				case ffjtGlobalPropertyParameters:
					goto handle_Parameters

				case ffjtGlobalPropertyPendingParameters:
					goto handle_PendingParameters

				case ffjtGlobalPropertyNextAvailableVoteID:
					goto handle_NextAvailableVoteID

				case ffjtGlobalPropertyActiveCommitteeMembers:
					goto handle_ActiveCommitteeMembers

				case ffjtGlobalPropertyActiveWitnesses:
					goto handle_ActiveWitnesses

				case ffjtGlobalPropertynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=types.GlobalPropertyID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.ID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Parameters:

	/* handler: j.Parameters type=types.ChainParametersType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Parameters.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PendingParameters:

	/* handler: j.PendingParameters type=types.ChainParametersType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PendingParameters = nil

		} else {

			if j.PendingParameters == nil {
				j.PendingParameters = new(ChainParametersType)
			}

			err = j.PendingParameters.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NextAvailableVoteID:

	/* handler: j.NextAvailableVoteID type=types.UInt32 kind=uint32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.NextAvailableVoteID.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveCommitteeMembers:

	/* handler: j.ActiveCommitteeMembers type=types.CommitteeMemberIDs kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for CommitteeMemberIDs", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ActiveCommitteeMembers = nil
		} else {

			j.ActiveCommitteeMembers = []CommitteeMemberID{}

			wantVal := true

			for {

				var tmpJActiveCommitteeMembers CommitteeMemberID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJActiveCommitteeMembers type=types.CommitteeMemberID kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJActiveCommitteeMembers.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ActiveCommitteeMembers = append(j.ActiveCommitteeMembers, tmpJActiveCommitteeMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ActiveWitnesses:

	/* handler: j.ActiveWitnesses type=types.WitnessIDs kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for WitnessIDs", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ActiveWitnesses = nil
		} else {

			j.ActiveWitnesses = []WitnessID{}

			wantVal := true

			for {

				var tmpJActiveWitnesses WitnessID

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJActiveWitnesses type=types.WitnessID kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJActiveWitnesses.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ActiveWitnesses = append(j.ActiveWitnesses, tmpJActiveWitnesses)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
